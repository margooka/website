<!DOCTYPE html>
<html>
<head>
<style>
	p {font-family:"Courier";}
.collapsible {
  background-color: #777;
  color: white;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: none;
  text-align: left;
  outline: none;
  font-size: 15px;
}

.active, .collapsible:hover {
  background-color: #555;
}

.collapsible:after {
  content: '\002B';
  color: white;
  font-weight: bold;
  float: right;
  margin-left: 5px;
}

.active:after {
  content: "\2212";
}

.content {
  padding: 0 18px;
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.2s ease-out;
  background-color: #f1f1f1;
}
</style>
</head>

<body>
<p><a href="./index.html">home</a></p>

<p>Over the last few years I've written notes on various computer science topics. For the most part these were written with the intent of teaching other students so parts may be informal and lack thorough explanation.</p>

<button class="collapsible">B-Trees</button>
<div class="content">

<p>
</br>B-Trees are used to reduce the height of a tree as you add to it i.e. making sure the tree is not "splindly." They are self-balancing trees
</br>B-Trees of order L=2 are 2-3 Trees and B-Trees of order L=3 are 2-3-4 Trees (2-4 Trees).
</br>2-3 Trees have at most 2 elements per node and at most 3 children per node.
</br>2-3-4 Trees have at most 3 elements per node and at most 4 children per node.
</br>2-3 Tree:
</br><center><img src="teaching/2-3tree.png" alt="2-3" height="400"></center>
</br>2-3-4 Tree:
</br><center><img src="teaching/2-3-4tree.png" alt="2-3-4" height="400"></center>

</br>Note: you can have other types of elements in your B-Tree such as letters or arbitrary objects (so long as these objects can be ordered).
</br>Algorithm for searching for an element of a 2-3 Tree:
<ul>
  <li>(Similar to <b>searching</b> in a BST)</li>
  <li>Look at each node and determine which child to continur your search in </li>
  <ul>
  	<li>Repeat until element is found</li>
  </ul>
</ul>

</br>Algorithm for <b>inserting</b> an element into a 2-3 Tree:
<ul>
 	<li>Insert element into the leaf node that it should be added to</li>
 	<ul>
 		<li>If node is not full</li>
 		<ul>
 			<li>Add that element to the node</li>
 		</ul>
 		<li>If leaf node is full</li>
 		<ul>
 			<li>Split the elements of the full node plus the new element into two child nodes with the median of the three elements acting as the parent</li>
 			<li>If possible, add this element to the original parent node</li>
 			<li>If not possible, continue this splitting process upwards</li>
 			<li>If the process continues to the root node create a new node above the root</li>
 			<ul>
 				<li>Note: this is the only time where the height of the tree can be increased</li>
 			</ul>
 		</ul>
 	</ul>
</ul> 
</br> Algorithm for <b>deleting</b> an element from a 2-3 Tree:
<ul>
	<li>(There are a few different algorithms)</li>
	<li>(It's hard)</li>
</ul>
</br><b>B-Tree Invariants</b> (things that are always true):
<ul>
	<li>All leaf nodes are the same distance from the root</li>
	<li>If a non-leaf node contains n elements, it has n+1 children</li>
	<li>Every node (other than the root) is at least half full</li>
	<li>>The root has at least two children as long as the height is &lt; 1</li>
</ul>

</br><b>Time Complexity:</b>
</br>Searching for a node: <b>O(logn)</b>
</br>Insertion: <b>O(logn)</b>
</br>Deletion: <b>O(logn)</b>
</p>
</div>



<script>
var coll = document.getElementsByClassName("collapsible");
var i;

for (i = 0; i < coll.length; i++) {
  coll[i].addEventListener("click", function() {
    this.classList.toggle("active");
    var content = this.nextElementSibling;
    if (content.style.maxHeight){
      content.style.maxHeight = null;
    } else {
      content.style.maxHeight = content.scrollHeight + "px";
    } 
  });
}
</script>

</body>
</html>
